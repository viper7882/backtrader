#!/usr/bin/env python
# -*- coding: utf-8; py-indent-offset:4 -*-
###############################################################################
#
# Copyright (C) 2015-2020 Daniel Rodriguez
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import collections
import datetime
import inspect
import itertools

from copy import copy
from .metabase import MetaParams
from .utils import AutoOrderedDict
from .utils.py3 import range, with_metaclass, iteritems


class OrderExecutionBit(object):
    '''
    Intended to hold information about order execution. A "bit" does not
    determine if the order has been fully/partially executed, it just holds
    information.

    Member Attributes:

      - dt: datetime (float) execution time
      - size: how much was executed
      - price: execution price
      - closed: how much of the execution closed an existing postion
      - opened: how much of the execution opened a new position
      - opened_value: market value of the "opened" part
      - closed_value: market value of the "closed" part
      - closed_commission: commission for the "closed" part
      - opened_commission: commission for the "opened" part

      - value: market value for the entire bit size
      - commission: commission for the entire bit execution
      - profit_and_loss_amount: profit_and_loss_amount generated by this bit (if something was closed)
      - spread_in_ticks: spread of current market

      - position_size: current open position size
      - position_average_price: current open position price

    '''

    def __init__(self,
                 dt=None, size=0, price=0.0,
                 closed=0.0, closed_value=0.0, closed_commission=0.0,
                 opened=0.0, opened_value=0.0, opened_commission=0.0,
                 profit_and_loss_amount=0.0, spread_in_ticks=0.0,
                 position_size=0.0, position_average_price=0.0):

        self.dt = dt
        self.size = size
        self.price = price

        self.closed = closed
        self.opened = opened
        self.closed_value = closed_value
        self.opened_value = opened_value
        self.closed_commission = closed_commission
        self.opened_commission = opened_commission

        self.value = closed_value + opened_value
        self.commission_amount = closed_commission + opened_commission
        self.profit_and_loss_amount = profit_and_loss_amount
        self.spread_in_ticks = spread_in_ticks

        self.position_size = position_size
        self.position_average_price = position_average_price


class OrderData(object):
    '''
    Holds actual order data for Creation and Execution.

    In the case of Creation the request made and in the case of Execution the
    actual outcome.

    Member Attributes:

      - execution_bits : iterable of OrderExecutionBits for this OrderData

      - dt: datetime (float) creation/execution time
      - size: requested/executed size
      - price: execution price
        Note: if no price is given and no pricelimite is given, the closing
        price at the time or order creation will be used as reference
      - pricelimit: holds pricelimit for StopLimit (which has trigger first)
      - trailing_amount: absolute price distance in trailing stops
      - trailing_percent: percentage price distance in trailing stops

      - value: market value for the entire bit size
      - commission_amount: commission for the entire bit execution
      - profit_and_loss_amount: profit_and_loss_amount generated by this bit (if something was closed)
      - spread_in_ticks: spread of current market
      - margin: margin incurred by the Order (if any)

      - position_size: current open position size
      - position_average_price: current open position price

    '''
    # According to the docs, collections.deque is thread-safe with appends at
    # both ends, there will be no pop (nowhere) and therefore to know which the
    # new execution_bits are two indices are needed. At time of cloning (__copy__) the
    # indices can be updated to match the previous end, and the new end
    # (len(execution_bits)
    # Example: start 0, 0 -> islice(execution_bits, 0, 0) -> []
    # One added -> copy -> updated 0, 1 -> islice(execution_bits, 0, 1) -> [1 elem]
    # Other added -> copy -> updated 1, 2 -> islice(execution_bits, 1, 2) -> [1 elem]
    # "add" and "__copy__" happen always in the same thread (with all current
    # implementations) and therefore no append will happen during a copy and
    # the len of the execution_bits can be queried with no concerns about another
    # thread making an append and with no need for a lock

    def __init__(self, dt=None, size=0, price=0.0, base_price=0.0, pricelimit=0.0, remaining_size=0.0,
                 closing_price=0.0, trailing_amount=0.0, trailing_percent=0.0, spread_in_ticks=0.0, filled_size=0.0):

        self.closing_price = closing_price
        self.execution_bits = collections.deque()  # for historical purposes
        self.p1, self.p2 = 0, 0  # indices to pending notifications

        self.dt = dt
        self.size = size
        self.filled_size = filled_size
        self.remaining_size = remaining_size

        # Execution price for conditional order. Required if you make limit price order
        self.price = price

        # It will be used to compare with the value of Trigger price, to decide whether your conditional order will be
        # triggered by crossing trigger price from upper side or lower side. Mainly used to identify the expected
        # direction of the current conditional order.
        # MJ: Just keep this in mind - base_price and lastPrice/markPrice should be on the same side compared to stop_px
        #     For e.g. If Trigger price > base_price and Trigger price < markPrice/lastPrice, it'd fail
        # MJ: To indicate if you're expecting the price to rise or fall compared to the current price
        #     Trigger price lower than base_price meaning you'd expect markPrice/lastPrice to fall to trigger the order.
        #     If the lastPrice/markPrice is even lower, it won't fall to trigger the order.
        #     Just make sure lastPrice/markPrice and base price is on the same side of Trigger price
        # Jim Davis: The conclusion is that the purpose of base_price is to be able to create stop on both side.
        #            For example, buy stop above the current price, and buy stop below the current price.
        # Dexter: If you want a take profit order for a long position, then you want it to be triggered from a
        #         lower price (therefore base_price should be below stop_px).
        #         For a short position, the other way around. Try experimenting with the values yourself, and you
        #         will see the API will return certain errors
        self.base_price = base_price

        # Trigger price/stop_px for conditional order.
        # If you're expecting the price to rise to trigger your conditional order,
        # make sure stop_px > max(lastprice/MarkPrice, base_price)
        # else stop_px < min(lastprice/MarkPrice, base_price)
        self.pricelimit = pricelimit

        self.trailing_amount = trailing_amount
        self.trailing_percent = trailing_percent
        self.spread_in_ticks = spread_in_ticks

        if not pricelimit:
            # if no pricelimit is given, use the given price
            self.pricelimit = self.price

        if pricelimit and not price:
            # price must always be set if pricelimit is set ...
            self.price = pricelimit

        self.price_limit = pricelimit

        self.value = 0.0
        self.commission_amount = 0.0
        self.margin = None
        self.profit_and_loss_amount = 0.0

        self.position_size = 0
        self.position_average_price = 0

    def _get_price_limit(self):
        return self._price_limit

    def _set_price_limit(self, val):
        self._price_limit = val

    price_limit = property(_get_price_limit, _set_price_limit)

    def __len__(self):
        return len(self.execution_bits)

    def __getitem__(self, key):
        return self.execution_bits[key]

    def add(self, dt, size, price,
            closed=0.0, closed_value=0.0, closed_commission=0.0,
            opened=0.0, opened_value=0.0, opened_commission=0.0,
            profit_and_loss_amount=0.0, spread_in_ticks=0.0,
            position_size=0.0, position_average_price=0.0):

        self.add_execution_bit(
            OrderExecutionBit(dt, size, price,
                              closed=closed, closed_value=closed_value, closed_commission=closed_commission,
                              opened=opened, opened_value=opened_value, opened_commission=opened_commission,
                              profit_and_loss_amount=profit_and_loss_amount, spread_in_ticks=spread_in_ticks,
                              position_size=position_size, position_average_price=position_average_price))

    def add_execution_bit(self, execution_bit):
        assert execution_bit.price != 0.0
        assert execution_bit.size != 0.0

        # Stores an ExecutionBit and recalculates own values from ExBit
        self.execution_bits.append(execution_bit)

        self.filled_size += execution_bit.size
        self.remaining_size -= execution_bit.size

        self.dt = execution_bit.dt
        old_value = self.size * self.price
        new_value = execution_bit.size * execution_bit.price
        self.size += execution_bit.size
        self.price = (old_value + new_value) / (self.size or 1.0)
        self.value += execution_bit.value
        self.commission_amount += execution_bit.commission_amount
        self.profit_and_loss_amount += execution_bit.profit_and_loss_amount
        self.spread_in_ticks = execution_bit.spread_in_ticks
        self.position_size = execution_bit.position_size
        self.position_average_price = execution_bit.position_average_price

    def get_pending(self):
        return list(self.iterate_pending())

    def iterate_pending(self):
        return itertools.islice(self.execution_bits, self.p1, self.p2)

    def mark_pending(self):
        # rebuild the indices to mark which execution_bits are pending in clone
        self.p1, self.p2 = self.p2, len(self.execution_bits)

    def clone(self):
        self.mark_pending()
        obj = copy(self)
        return obj


class OrderBase(with_metaclass(MetaParams, object)):
    params = (
        ('owner', None),
        ('datafeed', None),
        ('size', None),
        ('price', None),
        ('base_price', None),
        ('pricelimit', None),
        ('execution_type', None),
        ('spread_in_ticks', None),
        ('valid', None),
        ('tradeid', 0),
        ('oco', None),
        ('trailing_amount', None),
        ('trailing_percent', None),
        ('parent', None),
        ('transmit', True),
        ('simulated', False),
        # To support historical order evaluation
        ('histnotify', False),
    )

    DAY = datetime.timedelta()  # constant for DAY order identification

    # Time Restrictions for orders
    T_Close, T_Day, T_Date, T_None = range(4)

    # Volume Restrictions for orders
    V_None = range(1)

    Execution_Types = \
        ('Market', 'Close', 'Limit', 'StopMarket', 'StopLimit', 'StopTrail', 'StopTrailLimit', 'Historical', )
    Market, Close, Limit, StopMarket, StopLimit, StopTrail, StopTrailLimit, Historical, = range(len(Execution_Types))

    Order_Types = ('Buy', 'Sell', )
    Buy, Sell, = range(len(Order_Types))

    Ordering_Types = ("Active", "Conditional", )
    ACTIVE_ORDERING_TYPE, CONDITIONAL_ORDERING_TYPE, = range(len(Ordering_Types))

    Order_Intents = ('Entry', 'Exit', )
    Entry_Order, Exit_Order, = range(len(Order_Intents))

    Status = \
        ('Created', 'Submitted', 'Accepted', 'Partial', 'Completed', 'Canceled', 'Expired', 'Margin', 'Rejected', )
    Created, Submitted, Accepted, Partial, Completed, Canceled, Expired, Margin, Rejected, = range(len(Status))

    Cancelled = Canceled  # alias

    refbasis = itertools.count(1)  # for a unique identifier per order

    def _get_price_limit(self):
        return self._price_limit

    def _set_price_limit(self, val):
        self._price_limit = val

    price_limit = property(_get_price_limit, _set_price_limit)

    def __getattr__(self, name):
        # Return attr from params if not found in order
        return getattr(self.params, name)

    def __set_attribute__(self, name, value):
        if hasattr(self.params, name):
            setattr(self.params, name, value)
        else:
            super(Order, self).__set_attribute__(name, value)

    def __repr__(self):
        return str(self)

    def __str__(self):
        tojoin = list()
        tojoin.append('Reference ID: {}'.format(self.ref))
        tojoin.append('Datafeed: {}'.format(self.p.datafeed._name))
        tojoin.append('Order Type: {}'.format(self.order_type))
        tojoin.append('Order Type Name: {}'.format(self.order_type_name()))
        tojoin.append('Ordering Type: {}'.format(self.p.ordering_type))
        tojoin.append('Ordering Type Name: {}'.format(self.ordering_type_name()))
        tojoin.append('Order Intent: {}'.format(self.p.order_intent))
        tojoin.append('Order Intent Name: {}'.format(self.order_intent_name()))
        tojoin.append('Status: {}'.format(self.status))
        tojoin.append('Status Name: {}'.format(self.getstatusname()))
        tojoin.append('Size: {}'.format(self.size))
        tojoin.append('Price: {}'.format(self.price))
        tojoin.append('Base Price: {}'.format(self.base_price))
        tojoin.append('Price Limit: {}'.format(self.pricelimit))
        tojoin.append('Trailing Amount: {}'.format(self.trailing_amount))
        tojoin.append('Trailing Percent: {}'.format(self.trailing_percent))
        tojoin.append('Execution Type: {}'.format(self.execution_type))
        tojoin.append('Execution Type Name: {}'.format(self.execution_type_name()))
        tojoin.append('Spread in Ticks: {}'.format(self.p.spread_in_ticks))
        tojoin.append('Commission Info: {}'.format(self.commission_info))
        tojoin.append('End of Session: {}'.format(self.eos_dt))
        tojoin.append('Info: {}'.format(self.info))
        tojoin.append('Broker_or_Exchange: {}'.format(self.broker_or_exchange))
        tojoin.append('Alive: {}'.format(self.alive()))

        return '\n'.join(tojoin)

    def __init__(self):
        self.ref = next(self.refbasis)
        self.broker_or_exchange = None
        self.info = AutoOrderedDict()
        self.commission_info = None
        self.triggered = False

        self._active = self.parent is None
        self.status = Order.Created
        self.status_name = Order.Status[self.status]

        # INFO: Marks an order as partially filled earlier
        self.partially_filled_earlier = False

        # Legality Check
        if self.p.spread_in_ticks is not None:
            assert isinstance(self.p.spread_in_ticks, int) or isinstance(self.p.spread_in_ticks, float)
            assert self.p.spread_in_ticks >= 0.0

        self.price_limit = self.p.pricelimit  # alias via property

        if self.execution_type is None:
            self.execution_type = Order.Market

        if not self.is_buy():
            self.size = -self.size

        # Set a reference price if price is not set using
        # the close price
        closing_price = self.datafeed.close[0] if not self.simulated else self.price
        if not self.price and not self.pricelimit:
            price = closing_price
        else:
            price = self.price

        dcreated = self.datafeed.datetime[0] if not self.p.simulated else 0.0
        self.created = OrderData(dt=dcreated,
                                 size=self.size,
                                 price=price,
                                 base_price=self.base_price,
                                 pricelimit=self.pricelimit,
                                 closing_price=closing_price,
                                 trailing_amount=self.trailing_amount,
                                 trailing_percent=self.trailing_percent)

        # Adjust price in case a trailing limit is wished
        if self.execution_type in [Order.StopTrail, Order.StopTrailLimit]:
            self._limit_offset = self.created.price - self.created.pricelimit
            price = self.created.price
            self.created.price = float('inf' * self.is_buy() or '-inf')
            self.adjust_trailing_price(price)
        else:
            self._limit_offset = 0.0

        self.executed = OrderData(remaining_size=self.size)
        self.position = 0

        if isinstance(self.valid, datetime.date):
            # comparison will later be done against the raw datetime[0] value
            self.valid = self.datafeed.date2num(self.valid)
        elif isinstance(self.valid, datetime.timedelta):
            # offset with regards to now ... get utcnow + offset
            # when reading with date2num ... it will be automatically localized
            if self.valid == self.DAY:
                valid = datetime.datetime.combine(
                    self.datafeed.datetime.date(), datetime.time(23, 59, 59, 9999))
            else:
                valid = self.datafeed.datetime.datetime() + self.valid

            self.valid = self.datafeed.date2num(valid)

        elif self.valid is not None:
            if not self.valid:  # avoid comparing None and 0
                valid = datetime.datetime.combine(
                    self.datafeed.datetime.date(), datetime.time(23, 59, 59, 9999))
            else:  # assume float
                valid = self.datafeed.datetime[0] + self.valid

        if not self.p.simulated:
            # provisional end-of-session
            # get next session end
            dtime = self.datafeed.datetime.datetime(0)
            session = self.datafeed.p.session_end
            eos_dt = dtime.replace(hour=session.hour, minute=session.minute,
                                  second=session.second,
                                  microsecond=session.microsecond)

            if eos_dt < dtime:
                # eos before current time ... no ... must be at least next day
                eos_dt += datetime.timedelta(days=1)

            self.eos_dt = self.datafeed.date2num(eos_dt)
        else:
            self.eos_dt = 0.0

    def clone(self):
        # status, triggered and executed are the only moving parts in order
        # status and triggered are covered by copy
        # executed has to be replaced with an intelligent clone of itself
        obj = copy(self)
        obj.executed = self.executed.clone()
        return obj  # status could change in next to completed

    def getstatusname(self, status=None):
        '''Returns the name for a given status or the one of the order'''
        return self.Status[self.status if status is None else status]

    @classmethod
    def Execution_Type(cls, execution_type):
        return getattr(cls, execution_type)

    def order_type_name(self, order_type=None):
        '''Returns the name for a given order_type or the one of the order'''
        if order_type is not None:
            if order_type not in range(len(self.Order_Types)):
                raise ValueError("{} order_type must be one of {}!!!".format(
                    order_type, range(len(self.Order_Types))))
        return self.Order_Types[self.order_type if order_type is None else order_type]

    def ordering_type_name(self, ordering_type=None):
        '''Returns the name for a given ordering_type or the one of the order'''

        if ordering_type is not None:
            if ordering_type not in range(len(self.Ordering_Types)):
                raise ValueError("{} ordering_type must be one of {}!!!".format(
                    ordering_type, range(len(self.Ordering_Types))))

        own__ordering_type = None
        if hasattr(self, 'ordering_type'):
            '''
            Targeting 'AutoInfoClass_OrderBase_BT_CCXT_Order' object
            '''
            own__ordering_type = self.ordering_type
        elif hasattr(self.p, 'ordering_type'):
            own__ordering_type = self.p.ordering_type
        assert own__ordering_type is not None, "own__ordering_type must be defined!!!"
        return self.Ordering_Types[own__ordering_type if ordering_type is None else ordering_type]

    def order_intent_name(self, order_intent=None):
        '''Returns the name for a given order_intent or the one of the order'''
        if order_intent is not None:
            if order_intent not in range(len(self.Order_Intents)):
                raise ValueError("{} order_intent must be one of {}!!!".format(
                    order_intent, range(len(self.Order_Intents))))

        own__order_intent = None
        if hasattr(self, 'order_intent'):
            '''
            Targeting 'AutoInfoClass_OrderBase_BT_CCXT_Order' object
            '''
            own__order_intent = self.order_intent
        elif hasattr(self.p, 'order_intent'):
            own__order_intent = self.p.order_intent
        assert own__order_intent is not None, "own__order_intent must be defined!!!"
        return self.Order_Intents[own__order_intent if order_intent is None else order_intent]

    def execution_type_name(self, execution_type=None):
        '''Returns the name for a given execution_type or the one of the order'''
        if execution_type is not None:
            if execution_type not in range(len(self.Execution_Types)):
                raise ValueError("{} execution_type must be one of {}!!!".format(
                    execution_type, range(len(self.Execution_Types))))
        return self.Execution_Types[self.execution_type if execution_type is None else execution_type]

    def active(self):
        return self._active

    def activate(self):
        self._active = True

    def alive(self):
        '''Returns True if the order is in a status in which it can still be
        executed
        '''
        return self.status in [Order.Created, Order.Submitted, Order.Partial, Order.Accepted]

    def add_commission_info(self, commission_info):
        '''Stores a CommInfo scheme associated with the asset'''
        self.commission_info = commission_info

    def add_info(self, **kwargs):
        '''Add the keys, values of kwargs to the internal info dictionary to
        hold custom information in the order
        '''
        for key, val in iteritems(kwargs):
            self.info[key] = val

    def __eq__(self, other):
        return other is not None and self.ref == other.ref

    def __ne__(self, other):
        return self.ref != other.ref

    def is_buy(self):
        '''Returns True if the order is a Buy order'''
        return self.order_type == self.Buy

    def is_sell(self):
        '''Returns True if the order is a Sell order'''
        return self.order_type == self.Sell

    def set_position(self, position):
        '''Receives the current position for the asset and stores it'''
        self.position = position

    def submit(self, broker_or_exchange=None):
        '''Marks an order as submitted and stores the broker_or_exchange to which it was
        submitted'''
        self.status = Order.Submitted
        self.status_name = Order.Status[self.status]
        self.broker_or_exchange = broker_or_exchange
        self.plen = len(self.datafeed)

    def accept(self, broker_or_exchange=None):
        '''Marks an order as accepted'''
        self.status = Order.Accepted
        self.status_name = Order.Status[self.status]
        self.broker_or_exchange = broker_or_exchange

    def get_broker_or_exchange_status(self):
        '''Tries to retrieve the status from the broker_or_exchange in which the order is.

        Defaults to last known status if no broker_or_exchange is associated'''
        if self.broker_or_exchange:
            return self.broker_or_exchange.orderstatus(self)

        return self.status

    def reject(self, broker_or_exchange=None):
        '''Marks an order as rejected'''
        if self.status == Order.Rejected:
            return False

        self.status = Order.Rejected
        self.status_name = Order.Status[self.status]
        self.executed.dt = self.datafeed.datetime[0]
        self.broker_or_exchange = broker_or_exchange
        return True

    def cancel(self):
        '''Marks an order as cancelled'''
        self.status = Order.Canceled
        self.status_name = Order.Status[self.status]
        self.executed.dt = self.datafeed.datetime[0]

    def margin(self):
        '''Marks an order as having met a margin call'''
        self.status = Order.Margin
        self.status_name = Order.Status[self.status]
        self.executed.dt = self.datafeed.datetime[0]

    def completed(self):
        '''Marks an order as completely filled'''
        self.status = self.Completed
        self.status_name = Order.Status[self.status]

    def partial(self):
        '''Marks an order as partially filled'''
        self.status = self.Partial
        self.status_name = Order.Status[self.status]
        self.partially_filled_earlier = True

    def execute(self, dt, size, price,
                closed, closed_value, closed_commission,
                opened, opened_value, opened_commission,
                margin, profit_and_loss_amount, spread_in_ticks,
                position_size, position_average_price):

        '''Receives data execution input and stores it'''
        if not size:
            return

        self.executed.add(dt, size, price,
                          closed, closed_value, closed_commission,
                          opened, opened_value, opened_commission,
                          profit_and_loss_amount, spread_in_ticks,
                          position_size, position_average_price)

        self.executed.margin = margin

    def expire(self):
        '''Marks an order as expired. Returns True if it worked'''
        self.status = self.Expired
        self.status_name = Order.Status[self.status]
        return True

    def adjust_trailing_price(self, price):
        pass  # generic interface


class Order(OrderBase):
    '''
    Class which holds creation/execution data and type of oder.

    The order may have the following status:

      - Submitted: sent to the broker_or_exchange and awaiting confirmation
      - Accepted: accepted by the broker_or_exchange
      - Partial: partially executed
      - Completed: fully exexcuted
      - Canceled/Cancelled: canceled by the user
      - Expired: expired
      - Margin: not enough cash to execute the order.
      - Rejected: Rejected by the broker_or_exchange

        This can happen during order submission (and therefore the order will
        not reach the Accepted status) or before execution with each new bar
        price because cash has been drawn by other sources (future-like
        instruments may have reduced the cash or orders orders may have been
        executed)

    Member Attributes:

      - reference_id: unique order identifier
      - created: OrderData holding creation data
      - executed: OrderData holding execution data

      - info: custom information passed over method :func:`add_info`. It is kept
        in the form of an OrderedDict which has been subclassed, so that keys
        can also be specified using '.' notation

    User Methods:

      - is_buy(): returns bool indicating if the order buys
      - is_sell(): returns bool indicating if the order sells
      - alive(): returns bool if order is in status Partial or Accepted
    '''

    def execute(self, dt, size, price,
                closed, closed_value, closed_commission,
                opened, opened_value, opened_commission,
                margin, profit_and_loss_amount, spread_in_ticks,
                position_size, position_average_price):

        super(Order, self).execute(dt, size, price,
                                   closed, closed_value, closed_commission,
                                   opened, opened_value, opened_commission,
                                   margin, profit_and_loss_amount, spread_in_ticks,
                                   position_size, position_average_price)

        if self.executed.remaining_size:
            self.status = Order.Partial
        else:
            self.status = Order.Completed
        self.status_name = Order.Status[self.status]

        # self.commission_info = None

    def expire(self):
        if self.execution_type == Order.Market:
            return False  # will be executed yes or yes

        if self.valid and self.datafeed.datetime[0] > self.valid:
            self.status = Order.Expired
            self.status_name = Order.Status[self.status]
            self.executed.dt = self.datafeed.datetime[0]
            return True

        return False

    def adjust_trailing_price(self, price):
        if self.trailing_amount:
            pamount = self.trailing_amount
        elif self.trailing_percent:
            pamount = price * self.trailing_percent
        else:
            pamount = 0.0

        # Stop sell is below (-), stop buy is above, move only if needed
        if self.is_buy():
            price += pamount
            if price < self.created.price:
                self.created.price = price
                if self.execution_type == Order.StopTrailLimit:
                    self.created.pricelimit = price - self._limit_offset
        else:
            price -= pamount
            if price > self.created.price:
                self.created.price = price
                if self.execution_type == Order.StopTrailLimit:
                    # limitoffset is negative when pricelimit was greater
                    # the - allows increasing the price limit if stop increases
                    self.created.pricelimit = price - self._limit_offset


class Buy_Order(Order):
    order_type = Order.Buy


class Buy_Stop_Market_Order(Buy_Order):
    pass


class Buy_Stop_limit_Order(Buy_Order):
    pass


class Sell_Order(Order):
    order_type = Order.Sell


class Sell_Stop_Market_Order(Sell_Order):
    pass


class Sell_Stop_Limit_Order(Sell_Order):
    pass
